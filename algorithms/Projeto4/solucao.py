# -*- coding: utf-8 -*-


"""
/***************************************************************************
 ProgramacaoAplicadaGrupo2
                                 A QGIS plugin
 Solução do Grupo 2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-05
        copyright            : (C) 2023 by Grupo 2
        email                : matheus.ferreira@ime.eb.br
                               leonardo.fernandes@ime.eb.br
                               daniel.nojima@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 2'
__date__ = '2023-05-05'
__copyright__ = '(C) 2023 by Grupo 2'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import pandas as pd
import geopandas as gpd

from qgis.PyQt.QtCore import QVariant, QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsWkbTypes,
                       QgsVectorLayer,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsWkbTypes,
                       QgsGeometry,
                       QgsPointXY,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFeatureSink
                    )

class Projeto4Solucao(QgsProcessingAlgorithm):

    """
    Definindo as constantes
    """
    
    MOLDURA_LAYER = 'MOLDURA_LAYER'
    LINHAS_LAYER = 'LINHAS_LAYER'
    TOLERANCE = 'TOLERANCE'
    BUFFER_DISTANCE = 'BUFFER_DISTANCE'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterFeatureSource(self.MOLDURA_LAYER, 'Camada Moldura', [QgsProcessing.TypeVectorPolygon]))
        self.addParameter(QgsProcessingParameterFeatureSource(self.LINHAS_LAYER, 'Camada Linhas', [QgsProcessing.TypeVectorLine]))
        self.addParameter(QgsProcessingParameterNumber(self.TOLERANCE, 'Tolerance', minValue=0.0, defaultValue=0.0001,type=QgsProcessingParameterNumber.Double))
        self.addParameter(QgsProcessingParameterNumber(self.BUFFER_DISTANCE, 'Buffer Distance', minValue=0.0, defaultValue=0.00002,type=QgsProcessingParameterNumber.Double))
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUTPUT, 'Camada de erros', QgsProcessing.TypeVectorPoint))

  
      
    def processAlgorithm(self, parameters, context, feedback):
        moldura_layer = self.parameterAsVectorLayer(parameters, self.MOLDURA_LAYER, context)
        linhas_layer = self.parameterAsVectorLayer(parameters, self.LINHAS_LAYER, context)
        tolerance = self.parameterAsDouble(parameters, self.TOLERANCE, context)
        buffer_distance = self.parameterAsDouble(parameters, self.BUFFER_DISTANCE, context)

        fields = QgsFields()
        fields.append(QgsField('new_field2', QVariant.String))

        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context,
                                                fields, QgsWkbTypes.Point, moldura_layer.sourceCrs())

        buffer_layer = self.create_buffer_layer(moldura_layer, buffer_distance)
        self.find_discontinuous_features(linhas_layer, buffer_layer, sink, tolerance)
        self.find_features_with_different_names(linhas_layer, buffer_layer, sink)

        return {self.OUTPUT: dest_id} 
       
       
       
       
       
        
    def tr(self, string):
        return QCoreApplication.translate('Processando', string)

    def createInstance(self):
        return Projeto4Solucao()

    def name(self):
        return 'Solução do Projeto 4'

    def displayName(self):
        return self.tr(self.name())

    def group(self):        
        return self.tr(self.groupId())

    def groupId(self):
        return 'Projeto 4'
        
    def shortHelpString(self):
        return self.tr("""ESCREVER AQUI"""
                       )
    
    """ 

    FUNÇÕES AUXILIARES

    """  

    def find_features_with_same_name(self,layer):
        name_to_feature = {}
        for feature in layer.getFeatures():
            if feature['nome'] not in name_to_feature:
                name_to_feature[feature['nome']] = []
            name_to_feature[feature['nome']].append(feature)
        return name_to_feature

    def find_discontinuous_features(self,layer, buffer_layer, sink, tolerance):
        name_to_feature = self.find_features_with_same_name(layer)
        errors = set()

        for buffer_feature in buffer_layer.getFeatures():
            buffer_geom = buffer_feature.geometry()

            for name, features in name_to_feature.items():
                if len(features) > 1:
                    for i in range(len(features)):
                        end_point_1 = features[i].geometry().asMultiPolyline()[-1][-1]
                        for j in range(i + 1, len(features)):
                            start_point_2 = features[j].geometry().asMultiPolyline()[0][0]
                            if buffer_geom.contains(end_point_1) and buffer_geom.contains(start_point_2):
                                if end_point_1.distance(start_point_2) <= tolerance:
                                    error_pair = tuple(sorted([features[i]['fid'], features[j]['fid']]))
                                    errors.add(error_pair)
                                    
                                    # Calcula o ponto médio
                                    midpoint = QgsPointXY((end_point_1.x() + start_point_2.x()) / 2, (end_point_1.y() + start_point_2.y()) / 2)
                                    
                                    # Cria uma nova feição de erro
                                    feat = QgsFeature()
                                    feat.setGeometry(QgsGeometry.fromPointXY(midpoint))
                                    feat.setAttributes(["Erro de geometria desconectada"])
                                    
                                    # Adiciona a feição à camada de erros
                                    sink.addFeature(feat)

        return errors


    def find_features_with_different_names(self,layer, buffer_layer, sink):
        errors = set()
        
        for buffer_feature in buffer_layer.getFeatures():
            buffer_geom = buffer_feature.geometry()

            features = [feature for feature in layer.getFeatures()]
            for i in range(len(features) - 1):
                end_point_1 = features[i].geometry().asMultiPolyline()[-1][-1]
                start_point_2 = features[i+1].geometry().asMultiPolyline()[0][0]
                
                if buffer_geom.contains(end_point_1) and buffer_geom.contains(start_point_2):
                    if features[i]['nome'] != features[i+1]['nome']:
                        error_pair = tuple(sorted([features[i]['fid'], features[i+1]['fid']]))
                        errors.add(error_pair)
                        
                        # Cria uma nova feição de erro
                        feat = QgsFeature()
                        feat.setGeometry(QgsGeometry.fromPointXY(end_point_1))
                        feat.setAttributes(["Erro de geometrias conectadas com conjuntos de atributos distintos."])

                        # Adiciona a feição à camada de erros
                        sink.addFeature(feat)
        return errors


    def create_buffer_layer(self,moldura_layer, buffer_distance):
        buffer_layer = QgsVectorLayer("Polygon", "buffer_layer", "memory")
        pr = buffer_layer.dataProvider()

        for moldura_feature in moldura_layer.getFeatures():
            moldura_geom = moldura_feature.geometry()

            # Desconstruir a geometria do polígono em linhas individuais
            for ring in moldura_geom.asMultiPolygon():
                for line in ring:
                    line_geom = QgsGeometry.fromPolylineXY(line)

                    # Cria um buffer em torno da linha
                    buffer_geom = line_geom.buffer(buffer_distance, 5)

                    # Cria e adiciona a feição de buffer
                    buffer_feature = QgsFeature()
                    buffer_feature.setGeometry(buffer_geom)
                    pr.addFeature(buffer_feature)

        buffer_layer.updateExtents() 
        return buffer_layer