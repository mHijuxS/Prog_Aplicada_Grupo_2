# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo2
                                 A QGIS plugin
 Solução do Grupo 2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-05
        copyright            : (C) 2023 by Grupo 2
        email                : matheus.ferreira@ime.eb.br
                               leonardo.fernandes@ime.eb.br
                               daniel.nojima@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 2'
__date__ = '2023-05-05'
__copyright__ = '(C) 2023 by Grupo 2'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterDistance,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsGeometry,
                       QgsWkbTypes,
                       QgsProcessingFeatureSourceDefinition,
                       QgsProcessingFeatureSource,
                       QgsProcessingFeedback,
                       QgsProcessingContext,
                       QgsVectorLayer,
                       QgsVectorFileWriter,
                       QgsFeatureSink,
                       QgsProcessingException)

from qgis import processing

class Projeto4SolucaoComplementar(QgsProcessingAlgorithm):
    BUILDINGS = 'BUILDINGS'
    GRID = 'GRID'
    DISTANCE = 'DISTANCE'
    BUFFER_DISTANCE = 'BUFFER_DISTANCE'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.BUILDINGS, 'Camada de Edificações', [QgsProcessing.TypeVectorPolygon]))
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.GRID, 'Camada de Molduras', [QgsProcessing.TypeVectorPolygon]))
        self.addParameter(
            QgsProcessingParameterNumber(
                self.DISTANCE, 'Distância de deslocamento', minValue=0, defaultValue=20))
        self.addParameter(
            QgsProcessingParameterDistance(
                self.BUFFER_DISTANCE,
                'Buffer Distance',
                defaultValue=1.0
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT, 'Intersecções'))

    def processAlgorithm(self, parameters, context, feedback):
        source_buildings = self.parameterAsVectorLayer(parameters, self.BUILDINGS, context)
        source_grid = self.parameterAsVectorLayer(parameters, self.GRID, context)
        distance = self.parameterAsDouble(parameters, self.DISTANCE, context)
        buffer_distance = self.parameterAsDouble(parameters, self.BUFFER_DISTANCE, context)

        fix_result = processing.run('native:fixgeometries', {
            'INPUT': source_buildings,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        source_buildings_fixed = fix_result['OUTPUT']

        buffer_result_positive = processing.run('native:buffer', {
            'INPUT': source_grid,
            'DISTANCE': distance,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        buffer_result_negative = processing.run('native:buffer', {
            'INPUT': source_grid,
            'DISTANCE': -distance,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        buffer_result_difference = processing.run('native:difference', {
            'INPUT': buffer_result_positive['OUTPUT'],
            'OVERLAY': buffer_result_negative['OUTPUT'],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        intersection_result = processing.run('native:intersection', {
            'INPUT': source_buildings_fixed,
            'OVERLAY': buffer_result_difference['OUTPUT'],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        # Buffers the intersected polygons
        total = 100.0 / intersection_result['OUTPUT'].featureCount() if intersection_result['OUTPUT'].featureCount() else 0
        features = intersection_result['OUTPUT'].getFeatures()

        buffer_features = []
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break

            geometry = feature.geometry()
            buffered = geometry.buffer(buffer_distance, 5)

            if buffered.isEmpty():
                continue

            new_feature = QgsFeature(feature)
            new_feature.setGeometry(buffered)
            buffer_features.append(new_feature)

            feedback.setProgress(int(current * total))

        buffer_layer = QgsVectorLayer("Polygon?crs=epsg:4326", "buffered", "memory")
        pr = buffer_layer.dataProvider()
        pr.addFeatures(buffer_features)

        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context,
                                               buffer_layer.fields(), buffer_layer.wkbType(),
                                               buffer_layer.sourceCrs())

        # Extracts boundaries from the grid layer
        boundaries_result = processing.run('native:boundary', {
            'INPUT': source_grid,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        total = 100.0 / buffer_layer.featureCount() if buffer_layer.featureCount() else 0
        poly_features = buffer_layer.getFeatures()

        for current, poly_feat in enumerate(poly_features):
            if feedback.isCanceled():
                break

            poly_geom = poly_feat.geometry()

            line_features = boundaries_result['OUTPUT'].getFeatures()
            for line_feat in line_features:
                line_geom = line_feat.geometry()

                if poly_geom.intersects(line_geom):
                    intersected_geom = poly_geom.intersection(line_geom)

                    if intersected_geom.wkbType() == QgsWkbTypes.LineString:
                        new_feature = QgsFeature(line_feat)
                        new_feature.setGeometry(intersected_geom)
                        sink.addFeature(new_feature, QgsFeatureSink.FastInsert)

            feedback.setProgress(int(current * total))

        return {self.OUTPUT: dest_id}

    def name(self):
        return 'Solução Complementar do Projeto 4'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Projeto 3'

    def shortHelpString(self):
        return self.tr("""
                          """
                       )
    
    def tr(self, string):
        return QCoreApplication.translate('Processando', string)

    def createInstance(self):
        return Projeto4SolucaoComplementar()
    
    