# -*- coding: utf-8 -*-

"""
/***************************************************************************
 ProgramacaoAplicadaGrupo2
                                 A QGIS plugin
 Solução do Grupo 2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-05-05
        copyright            : (C) 2023 by Grupo 2
        email                : matheus.ferreira@ime.eb.br
                               leonardo.fernandes@ime.eb.br
                               daniel.nojima@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Grupo 2'
__date__ = '2023-05-05'
__copyright__ = '(C) 2023 by Grupo 2'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterDistance,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsGeometry,
                       QgsWkbTypes,
                       QgsProcessingFeatureSourceDefinition,
                       QgsProcessingFeatureSource,
                       QgsProcessingFeedback,
                       QgsProcessingContext,
                       QgsVectorLayer,
                       QgsVectorFileWriter,
                       QgsFeatureSink,
                       QgsProcessingException)

from qgis import processing

class Projeto4SolucaoComplementar(QgsProcessingAlgorithm):
    BUILDINGS = 'BUILDINGS'
    GRID = 'GRID'
    DISTANCE = 'DISTANCE'
    BUFFER_DISTANCE = 'BUFFER_DISTANCE'
    OUTPUT = 'OUTPUT'

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.BUILDINGS, 'Camada de Edificações', [QgsProcessing.TypeVectorPolygon]))
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.GRID, 'Camada de Molduras', [QgsProcessing.TypeVectorPolygon]))
        self.addParameter(
            QgsProcessingParameterNumber(
                self.DISTANCE, 'Distância de deslocamento', minValue=0, defaultValue=20))
        self.addParameter(
            QgsProcessingParameterDistance(
                self.BUFFER_DISTANCE,
                'Buffer Distance',
                defaultValue=1.0
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT, 'Intersecções'))

    def processAlgorithm(self, parameters, context, feedback):
        source_buildings = self.parameterAsVectorLayer(parameters, self.BUILDINGS, context)
        source_grid = self.parameterAsVectorLayer(parameters, self.GRID, context)
        distance = self.parameterAsDouble(parameters, self.DISTANCE, context)
        buffer_distance = self.parameterAsDouble(parameters, self.BUFFER_DISTANCE, context)

        fix_result = processing.run('native:fixgeometries', {
            'INPUT': source_buildings,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        source_buildings_fixed = fix_result['OUTPUT']

        buffer_result_positive = processing.run('native:buffer', {
            'INPUT': source_grid,
            'DISTANCE': distance,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        buffer_result_negative = processing.run('native:buffer', {
            'INPUT': source_grid,
            'DISTANCE': -distance,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        buffer_result_difference = processing.run('native:difference', {
            'INPUT': buffer_result_positive['OUTPUT'],
            'OVERLAY': buffer_result_negative['OUTPUT'],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        intersection_result = processing.run('native:intersection', {
            'INPUT': source_buildings_fixed,
            'OVERLAY': buffer_result_difference['OUTPUT'],
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        # Buffers the intersected polygons
        total = 100.0 / intersection_result['OUTPUT'].featureCount() if intersection_result['OUTPUT'].featureCount() else 0
        features = intersection_result['OUTPUT'].getFeatures()

        buffer_features = []
        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break

            geometry = feature.geometry()
            buffered = geometry.buffer(buffer_distance, 5)

            if buffered.isEmpty():
                continue

            new_feature = QgsFeature(feature)
            new_feature.setGeometry(buffered)
            buffer_features.append(new_feature)

            feedback.setProgress(int(current * total))

        buffer_layer = QgsVectorLayer("Polygon?crs=epsg:4326", "buffered", "memory")
        pr = buffer_layer.dataProvider()
        pr.addFeatures(buffer_features)

        (sink, dest_id) = self.parameterAsSink(parameters, self.OUTPUT, context,
                                               buffer_layer.fields(), buffer_layer.wkbType(),
                                               buffer_layer.sourceCrs())

        # Extracts boundaries from the grid layer
        boundaries_result = processing.run('native:boundary', {
            'INPUT': source_grid,
            'OUTPUT': 'memory:'
        }, context=context, feedback=feedback)

        total = 100.0 / buffer_layer.featureCount() if buffer_layer.featureCount() else 0
        poly_features = buffer_layer.getFeatures()

        for current, poly_feat in enumerate(poly_features):
            if feedback.isCanceled():
                break

            poly_geom = poly_feat.geometry()

            line_features = boundaries_result['OUTPUT'].getFeatures()
            for line_feat in line_features:
                line_geom = line_feat.geometry()

                if poly_geom.intersects(line_geom):
                    intersected_geom = poly_geom.intersection(line_geom)

                    if intersected_geom.wkbType() == QgsWkbTypes.LineString:
                        new_feature = QgsFeature(line_feat)
                        new_feature.setGeometry(intersected_geom)
                        sink.addFeature(new_feature, QgsFeatureSink.FastInsert)

            feedback.setProgress(int(current * total))

        return {self.OUTPUT: dest_id}

    def name(self):
        return 'Solução Complementar do Projeto 4'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return 'Projeto 3'

    def shortHelpString(self):
        return self.tr("""
                          """
                       )
    
    def tr(self, string):
        return QCoreApplication.translate('Processando', string)

    def createInstance(self):
        return Projeto4SolucaoComplementar()
    
    